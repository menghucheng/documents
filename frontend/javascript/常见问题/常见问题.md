# JavaScript 常见问题

## 1. 变量和数据类型

### 1.1 变量声明方式的区别（var、let、const）

**问题描述**：开发者不理解 `var`、`let` 和 `const` 之间的区别，导致变量作用域和可变性问题。

**解决方案**：
- `var`：函数作用域，存在变量提升，可重复声明，可重新赋值
- `let`：块级作用域，不存在变量提升，不可重复声明，可重新赋值
- `const`：块级作用域，不存在变量提升，不可重复声明，不可重新赋值（但对象和数组的属性可以修改）

**最佳实践**：优先使用 `const`，只有当需要重新赋值时使用 `let`，避免使用 `var`。

**示例**：
```javascript
// var 的问题：变量提升和函数作用域
console.log(x); // undefined（变量提升）
var x = 10;

function test() {
  if (true) {
    var y = 20;
  }
  console.log(y); // 20（函数作用域，y 在整个函数内可见）
}

test();

// let 和 const：块级作用域
console.log(a); // ReferenceError（不存在变量提升）
let a = 30;

if (true) {
  let b = 40;
  const c = 50;
  console.log(b); // 40
  console.log(c); // 50
}

// console.log(b); // ReferenceError（b 只在块内可见）
// console.log(c); // ReferenceError（c 只在块内可见）

// const 不可重新赋值，但对象属性可以修改
const person = { name: "张三" };
person.name = "李四"; // 允许
// person = { name: "王五" }; // TypeError（不允许重新赋值）
```

### 1.2 类型转换问题

**问题描述**：JavaScript 中的类型转换（隐式转换和显式转换）导致意外结果。

**解决方案**：
- 理解 JavaScript 的类型转换规则
- 使用显式转换避免意外结果
- 使用 `===` 和 `!==` 进行严格相等比较，避免 `==` 和 `!=` 的隐式转换

**示例**：
```javascript
// 隐式转换问题
console.log(1 + "2"); // "12"（数字转字符串）
console.log(1 - "2"); // -1（字符串转数字）
console.log("1" == 1); // true（隐式转换）
console.log("1" === 1); // false（严格比较，类型不同）
console.log([] == false); // true（隐式转换）
console.log({} == false); // false（隐式转换）

// 显式转换
console.log(Number("123")); // 123（字符串转数字）
console.log(String(123)); // "123"（数字转字符串）
console.log(Boolean(0)); // false（数字转布尔值）
console.log(Boolean("")); // false（字符串转布尔值）
console.log(Boolean([])); // true（数组转布尔值）
console.log(Boolean({})); // true（对象转布尔值）

// 推荐使用严格比较
const x = 10;
const y = "10";
if (x === y) {
  console.log("相等");
} else {
  console.log("不相等"); // 输出：不相等
}
```

### 1.3 NaN 的处理

**问题描述**：`NaN`（Not a Number）的特殊性导致比较和判断问题。

**解决方案**：
- `NaN` 不等于任何值，包括它自己
- 使用 `isNaN()` 或 `Number.isNaN()` 判断一个值是否为 `NaN`
- `Number.isNaN()` 比 `isNaN()` 更严格，只对数值类型的 `NaN` 返回 `true`

**示例**：
```javascript
console.log(NaN === NaN); // false（NaN 不等于任何值）
console.log(isNaN(NaN)); // true
console.log(isNaN("abc")); // true（"abc" 被隐式转换为 NaN）
console.log(Number.isNaN(NaN)); // true
console.log(Number.isNaN("abc")); // false（"abc" 不是数值类型）

// 正确判断 NaN 的方法
function isNaNValue(value) {
  return Number.isNaN(value) || (typeof value === "number" && isNaN(value));
}

console.log(isNaNValue(NaN)); // true
console.log(isNaNValue("abc")); // false
console.log(isNaNValue(123)); // false
```

## 2. 作用域和闭包

### 2.1 闭包的理解和使用

**问题描述**：开发者不理解闭包的概念和作用，或者滥用闭包导致内存泄漏。

**解决方案**：
- 闭包是指有权访问另一个函数作用域中变量的函数
- 闭包可以用来创建私有变量和函数
- 注意避免闭包导致的内存泄漏，及时清理引用

**示例**：
```javascript
// 闭包示例：创建私有变量
function createCounter() {
  let count = 0; // 私有变量
  
  return {
    increment: function() {
      count++;
      return count;
    },
    decrement: function() {
      count--;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.decrement()); // 1
console.log(counter.getCount()); // 1
// console.log(counter.count); // undefined（count 是私有变量，外部无法访问）

// 闭包导致的内存泄漏示例
function createElement() {
  const element = document.createElement('div');
  
  // 闭包引用了 element，导致 element 无法被垃圾回收
  element.addEventListener('click', function() {
    console.log('元素被点击');
  });
  
  return element;
}

// 解决方法：使用事件委托或及时移除事件监听器
function createElementSafe() {
  const element = document.createElement('div');
  
  const handleClick = function() {
    console.log('元素被点击');
  };
  
  element.addEventListener('click', handleClick);
  
  // 提供清理函数
  return {
    element: element,
    cleanup: function() {
      element.removeEventListener('click', handleClick);
    }
  };
}
```

### 2.2 作用域链和变量查找

**问题描述**：不理解 JavaScript 的作用域链和变量查找机制，导致变量访问错误。

**解决方案**：
- JavaScript 中的变量查找沿着作用域链向上查找，从当前作用域开始，直到全局作用域
- 如果找不到变量，会抛出 ReferenceError
- 注意变量遮蔽（shadowing）问题

**示例**：
```javascript
// 全局变量
const globalVar = "全局变量";

function outer() {
  // 外部函数变量
  const outerVar = "外部变量";
  
  function inner() {
    // 内部函数变量
    const innerVar = "内部变量";
    
    // 变量查找：innerVar -> outerVar -> globalVar
    console.log(innerVar); // 内部变量
    console.log(outerVar); // 外部变量
    console.log(globalVar); // 全局变量
    
    // 变量遮蔽
    const outerVar = "内部遮蔽变量";
    console.log(outerVar); // 内部遮蔽变量（遮蔽了外部函数的 outerVar）
  }
  
  inner();
}

outer();

// 变量查找失败
function test() {
  console.log(undefinedVar); // ReferenceError: undefinedVar is not defined
}

// test();
```

## 3. 异步编程

### 3.1 回调地狱（Callback Hell）

**问题描述**：多个嵌套的回调函数导致代码难以阅读和维护。

**解决方案**：
- 使用 Promise 链式调用
- 使用 async/await 语法
- 使用模块化和函数拆分

**示例**：
```javascript
// 回调地狱示例
function getUser(userId, callback) {
  setTimeout(() => {
    callback({ id: userId, name: "张三" });
  }, 1000);
}

function getPosts(userId, callback) {
  setTimeout(() => {
    callback([{ id: 1, title: "文章1" }, { id: 2, title: "文章2" }]);
  }, 1000);
}

function getComments(postId, callback) {
  setTimeout(() => {
    callback([{ id: 1, content: "评论1" }, { id: 2, content: "评论2" }]);
  }, 1000);
}

// 回调地狱
getUser(1, function(user) {
  console.log(user);
  getPosts(user.id, function(posts) {
    console.log(posts);
    getComments(posts[0].id, function(comments) {
      console.log(comments);
      // 更多嵌套回调...
    });
  });
});

// 使用 Promise 解决
function getUserPromise(userId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id: userId, name: "张三" });
    }, 1000);
  });
}

function getPostsPromise(userId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([{ id: 1, title: "文章1" }, { id: 2, title: "文章2" }]);
    }, 1000);
  });
}

function getCommentsPromise(postId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([{ id: 1, content: "评论1" }, { id: 2, content: "评论2" }]);
    }, 1000);
  });
}

// Promise 链式调用
getUserPromise(1)
  .then(user => {
    console.log(user);
    return getPostsPromise(user.id);
  })
  .then(posts => {
    console.log(posts);
    return getCommentsPromise(posts[0].id);
  })
  .then(comments => {
    console.log(comments);
  })
  .catch(error => {
    console.error(error);
  });

// 使用 async/await 解决
async function getContent() {
  try {
    const user = await getUserPromise(1);
    console.log(user);
    
    const posts = await getPostsPromise(user.id);
    console.log(posts);
    
    const comments = await getCommentsPromise(posts[0].id);
    console.log(comments);
  } catch (error) {
    console.error(error);
  }
}

// getContent();
```

### 3.2 Promise 的常见错误

**问题描述**：Promise 使用不当，如忘记返回 Promise、错误处理不当等。

**解决方案**：
- 确保在 Promise 链式调用中返回 Promise
- 使用 `catch()` 处理错误
- 避免 Promise 构造函数反模式
- 使用 `Promise.all()`、`Promise.race()` 等方法处理多个 Promise

**示例**：
```javascript
// 错误：忘记返回 Promise
function getUser() {
  return new Promise(resolve => {
    resolve({ id: 1, name: "张三" });
  });
}

function getPosts(userId) {
  return new Promise(resolve => {
    resolve([{ id: 1, title: "文章1" }]);
  });
}

// 错误示例
function fetchData() {
  getUser().then(user => {
    console.log(user);
    // 忘记 return
    getPosts(user.id).then(posts => {
      console.log(posts);
    });
  });
}

// 正确示例
function fetchDataCorrect() {
  return getUser()
    .then(user => {
      console.log(user);
      return getPosts(user.id); // 返回 Promise
    })
    .then(posts => {
      console.log(posts);
      return posts; // 返回结果
    });
}

// Promise 构造函数反模式
function fetchDataAntiPattern() {
  return new Promise((resolve, reject) => {
    // 反模式：不必要地包装已有的 Promise
    getUser().then(user => {
      resolve(user);
    }).catch(error => {
      reject(error);
    });
  });
}

// 正确：直接返回已有的 Promise
function fetchDataCorrect() {
  return getUser();
}

// 处理多个 Promise
Promise.all([
  getUserPromise(1),
  getPostsPromise(1),
  getCommentsPromise(1)
]).then(results => {
  const [user, posts, comments] = results;
  console.log(user, posts, comments);
}).catch(error => {
  console.error(error);
});
```

### 3.3 async/await 的错误处理

**问题描述**：async/await 中的错误处理不当，导致未捕获的异常。

**解决方案**：
- 使用 try/catch 块处理 await 表达式可能抛出的错误
- 确保所有 async 函数都有错误处理
- 注意 async/await 中的 Promise 拒绝

**示例**：
```javascript
// async/await 错误处理
async function fetchData() {
  try {
    const user = await getUserPromise(1);
    const posts = await getPostsPromise(user.id);
    const comments = await getCommentsPromise(posts[0].id);
    return { user, posts, comments };
  } catch (error) {
    console.error("获取数据失败:", error);
    throw error; // 可以选择重新抛出错误
  }
}

// 调用 async 函数
fetchData()
  .then(data => {
    console.log("成功获取数据:", data);
  })
  .catch(error => {
    console.error("处理异步函数错误:", error);
  });

// 注意：async 函数返回的是 Promise，需要处理拒绝
async function failingFunction() {
  throw new Error("故意失败");
}

// 不处理错误会导致未捕获的 Promise 拒绝
// failingFunction(); // 控制台会显示 Uncaught (in promise) Error: 故意失败

// 正确处理
failingFunction().catch(error => {
  console.error("捕获到错误:", error);
});
```

## 4. DOM 操作

### 4.1 DOM 事件委托

**问题描述**：直接为多个元素添加事件监听器导致性能问题和动态元素事件失效。

**解决方案**：
- 使用事件委托，将事件监听器添加到父元素上
- 利用事件冒泡机制，通过事件目标（target）判断触发事件的元素
- 减少事件监听器的数量，提高性能

**示例**：
```javascript
// 不推荐：为每个元素添加事件监听器
const buttons = document.querySelectorAll('.btn');
buttons.forEach(button => {
  button.addEventListener('click', function() {
    console.log('按钮被点击:', this.textContent);
  });
});

// 推荐：使用事件委托
const container = document.querySelector('.container');
container.addEventListener('click', function(e) {
  // 检查事件目标是否是按钮
  if (e.target.classList.contains('btn')) {
    console.log('按钮被点击:', e.target.textContent);
  }
});

// 动态添加的元素也能触发事件
const newButton = document.createElement('button');
newButton.className = 'btn';
newButton.textContent = '新按钮';
container.appendChild(newButton);
```

### 4.2 回流（Reflow）和重绘（Repaint）

**问题描述**：频繁的 DOM 操作导致浏览器回流和重绘，影响性能。

**解决方案**：
- 减少 DOM 操作次数，批量处理 DOM 更新
- 使用 DocumentFragment 或虚拟 DOM
- 避免频繁读取布局属性（如 offsetTop、clientWidth 等）
- 使用 CSS transforms 和 opacity 进行动画，避免回流
- 使用 will-change 提示浏览器优化

**示例**：
```javascript
// 不推荐：频繁的 DOM 操作
const container = document.querySelector('.container');
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `项目 ${i}`;
  container.appendChild(div); // 每次循环都会触发回流
}

// 推荐：使用 DocumentFragment 批量处理
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `项目 ${i}`;
  fragment.appendChild(div); // 只修改内存中的 DOM，不触发回流
}
container.appendChild(fragment); // 一次 DOM 操作，只触发一次回流

// 避免频繁读取布局属性
// 不推荐：
for (let i = 0; i < 1000; i++) {
  const height = container.offsetHeight; // 触发回流
  container.style.height = `${height + 1}px`; // 触发回流
}

// 推荐：
const height = container.offsetHeight; // 只读取一次
for (let i = 0; i < 1000; i++) {
  container.style.height = `${height + i + 1}px`; // 只修改样式，浏览器会批量处理
}

// 使用 CSS transforms 和 opacity 进行动画
const animatedElement = document.querySelector('.animated');
animatedElement.style.transform = 'translateX(100px)'; // 只触发复合层更新，不回流
animatedElement.style.opacity = '0.5'; // 只触发重绘，不回流
```

## 5. 数组和对象操作

### 5.1 数组方法的使用和返回值

**问题描述**：不理解数组方法的返回值和是否修改原数组，导致意外结果。

**解决方案**：
- 了解常用数组方法的特性：是否修改原数组、返回值是什么
- 区分 mutator（修改原数组）和 accessor（不修改原数组）方法
- 注意链式调用中的返回值

**示例**：
```javascript
const numbers = [1, 2, 3, 4, 5];

// 修改原数组的方法（mutator methods）
const pushResult = numbers.push(6);
console.log(numbers); // [1, 2, 3, 4, 5, 6]
console.log(pushResult); // 6（返回新的长度）

const popResult = numbers.pop();
console.log(numbers); // [1, 2, 3, 4, 5]
console.log(popResult); // 6（返回被删除的元素）

const spliceResult = numbers.splice(1, 2);
console.log(numbers); // [1, 4, 5]
console.log(spliceResult); // [2, 3]（返回被删除的元素数组）

// 不修改原数组的方法（accessor methods）
const sliceResult = numbers.slice(1, 3);
console.log(numbers); // [1, 4, 5]（原数组不变）
console.log(sliceResult); // [4, 5]（返回新数组）

const mapResult = numbers.map(num => num * 2);
console.log(numbers); // [1, 4, 5]（原数组不变）
console.log(mapResult); // [2, 8, 10]（返回新数组）

const filterResult = numbers.filter(num => num > 3);
console.log(numbers); // [1, 4, 5]（原数组不变）
console.log(filterResult); // [4, 5]（返回新数组）

// 注意：链式调用中的返回值
const chainResult = numbers
  .filter(num => num > 3)
  .map(num => num * 2)
  .reduce((sum, num) => sum + num, 0);
console.log(chainResult); // 18（(4*2)+(5*2) = 8+10=18）
```

### 5.2 对象的深拷贝和浅拷贝

**问题描述**：对象的赋值、浅拷贝和深拷贝混淆，导致意外修改原对象。

**解决方案**：
- 理解赋值、浅拷贝和深拷贝的区别
- 根据需求选择合适的拷贝方式
- 使用 `JSON.parse(JSON.stringify())` 进行简单的深拷贝
- 使用第三方库（如 Lodash 的 `cloneDeep`）进行复杂对象的深拷贝
- 注意特殊类型（如函数、日期、正则表达式）的拷贝

**示例**：
```javascript
const original = {
  name: "张三",
  age: 25,
  address: {
    city: "北京",
    district: "朝阳区"
  },
  hobbies: ["阅读", "运动"]
};

// 赋值：共享引用，修改会影响原对象
const assignment = original;
assignment.name = "李四";
console.log(original.name); // "李四"（原对象被修改）

// 浅拷贝：只拷贝第一层，嵌套对象仍共享引用
// 方法 1：Object.assign
const shallowCopy1 = Object.assign({}, original);
// 方法 2：扩展运算符
const shallowCopy2 = { ...original };

shallowCopy1.name = "王五";
console.log(original.name); // "李四"（原对象未修改）

shallowCopy1.address.city = "上海";
console.log(original.address.city); // "上海"（嵌套对象共享引用，原对象被修改）

// 深拷贝：完全拷贝，包括嵌套对象
// 方法 1：JSON.parse(JSON.stringify())（简单对象适用）
const deepCopy1 = JSON.parse(JSON.stringify(original));
deepCopy1.address.city = "广州";
console.log(original.address.city); // "上海"（原对象未修改）

// 注意：JSON.parse(JSON.stringify()) 的局限性
// 不支持函数、日期、正则表达式、undefined、Symbol 等
const complexObj = {
  name: "张三",
  func: function() { console.log("函数"); },
  date: new Date(),
  regex: /test/g,
  undefinedProp: undefined,
  symbolProp: Symbol("test")
};

const deepCopy2 = JSON.parse(JSON.stringify(complexObj));
console.log(deepCopy2.func); // undefined（函数被忽略）
console.log(deepCopy2.date); // 字符串形式的日期（不是 Date 对象）
console.log(deepCopy2.regex); // 字符串形式的正则（不是 RegExp 对象）
console.log(deepCopy2.undefinedProp); // 不存在（undefined 被忽略）
console.log(deepCopy2.symbolProp); // 不存在（Symbol 被忽略）

// 方法 2：使用第三方库（如 Lodash）
// const deepCopy3 = _.cloneDeep(complexObj);
```

## 6. 性能优化

### 6.1 函数节流（Throttle）和防抖（Debounce）

**问题描述**：频繁触发的事件（如 resize、scroll、input 等）导致性能问题。

**解决方案**：
- 使用节流（Throttle）：限制函数在一定时间内只能执行一次
- 使用防抖（Debounce）：延迟函数执行，直到事件停止触发一段时间后才执行
- 根据场景选择合适的优化方式

**示例**：
```javascript
// 节流函数
function throttle(func, delay) {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      return func.apply(this, args);
    }
  };
}

// 防抖函数
function debounce(func, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// 使用节流优化 scroll 事件
window.addEventListener('scroll', throttle(function() {
  console.log('滚动事件触发');
}, 100));

// 使用防抖优化 input 事件
const input = document.querySelector('input');
input.addEventListener('input', debounce(function(e) {
  console.log('输入内容:', e.target.value);
}, 300));
```

### 6.2 内存泄漏

**问题描述**：JavaScript 中的内存泄漏导致浏览器性能下降或崩溃。

**常见原因**：
- 意外的全局变量
- 未清理的事件监听器
- 未清理的定时器和计时器
- 闭包引用了不再需要的对象
- DOM 元素引用循环

**解决方案**：
- 避免意外的全局变量（使用严格模式 'use strict'）
- 及时移除事件监听器
- 清理定时器和计时器
- 避免不必要的闭包引用
- 使用 WeakMap 和 WeakSet 处理弱引用

**示例**：
```javascript
// 意外的全局变量（在非严格模式下）
function createGlobalVar() {
  // 忘记使用 var/let/const，变成全局变量
  globalVar = "意外的全局变量";
}

// 解决方案：使用严格模式
'use strict';

function createGlobalVarSafe() {
  // globalVar = "意外的全局变量"; // ReferenceError
  const safeVar = "安全变量";
}

// 未清理的事件监听器
const element = document.createElement('div');
function handleClick() {
  console.log('点击事件');
}
element.addEventListener('click', handleClick);

// 解决方案：移除事件监听器
element.removeEventListener('click', handleClick);

// 未清理的定时器
const timerId = setInterval(function() {
  console.log('定时器执行');
}, 1000);

// 解决方案：清理定时器
clearInterval(timerId);

// 使用 WeakMap 处理弱引用
const weakMap = new WeakMap();
const obj = { name: "张三" };
weakMap.set(obj, "附加数据");

// 当 obj 不再被引用时，会被垃圾回收，WeakMap 中的条目也会自动移除
obj = null;
```

## 7. 调试技巧

### 7.1 使用浏览器开发者工具

**问题描述**：开发者不熟悉浏览器开发者工具的使用，导致调试效率低下。

**解决方案**：
- 使用 Chrome DevTools 或 Firefox DevTools
- 利用 Console 面板进行日志输出和调试
- 使用 Sources 面板进行断点调试
- 使用 Network 面板分析网络请求
- 使用 Performance 面板分析性能
- 使用 Memory 面板分析内存使用

**示例**：
```javascript
// Console 面板技巧
console.log("普通日志");
console.warn("警告日志");
console.error("错误日志");
console.info("信息日志");

// 分组日志
console.group("用户信息");
console.log("姓名: 张三");
console.log("年龄: 25");
console.groupEnd();

// 表格日志
const users = [
  { name: "张三", age: 25 },
  { name: "李四", age: 30 }
];
console.table(users);

// 计时
console.time("耗时");
// 执行耗时操作
for (let i = 0; i < 1000000; i++) {
  // 循环操作
}
console.timeEnd("耗时");

// 断言
console.assert(1 === 2, "1 不等于 2"); // 断言失败，输出错误

// 断点调试
function debugFunction() {
  const x = 10;
  const y = 20;
  const result = x + y;
  console.log(result);
  return result;
}

// 在 Sources 面板中为 debugFunction 设置断点
// debugFunction();
```

### 7.2 错误处理和调试

**问题描述**：代码中缺乏适当的错误处理，导致难以定位和调试问题。

**解决方案**：
- 使用 try/catch 块处理可能的错误
- 为异步代码添加错误处理
- 使用 `console.trace()` 输出调用栈
- 使用 `debugger` 语句设置断点
- 利用 Source Maps 调试编译后的代码

**示例**：
```javascript
// 使用 try/catch 处理错误
try {
  const result = riskyOperation();
  console.log(result);
} catch (error) {
  console.error("错误发生:", error.message);
  console.trace(); // 输出调用栈
}

// 异步代码的错误处理
async function asyncFunction() {
  try {
    const result = await riskyAsyncOperation();
    console.log(result);
  } catch (error) {
    console.error("异步错误:", error);
  }
}

// 使用 debugger 语句
function debugWithDebugger() {
  const x = 10;
  debugger; // 在这里暂停执行
  const y = 20;
  const result = x + y;
  console.log(result);
}

// debugWithDebugger();
```

## 8. 最佳实践

### 8.1 代码风格和可维护性

**问题描述**：代码风格不一致，难以维护和阅读。

**解决方案**：
- 遵循一致的代码风格（如 Airbnb JavaScript 风格指南）
- 使用 ESLint 和 Prettier 等工具自动检查和格式化代码
- 编写清晰的函数和变量名
- 保持函数简短，单一职责
- 添加适当的注释
- 使用模块化设计

**示例**：
```javascript
// 好的代码风格
function calculateTotal(price, quantity, taxRate = 0.1) {
  /**
   * 计算总价
   * @param {number} price - 单价
   * @param {number} quantity - 数量
   * @param {number} taxRate - 税率（默认 10%）
   * @returns {number} 总价
   */
  const subtotal = price * quantity;
  const tax = subtotal * taxRate;
  const total = subtotal + tax;
  return total;
}

// 调用函数
const total = calculateTotal(100, 5);
console.log(`总价: ${total}`);

// 模块化设计
// math.js
// export function add(a, b) { return a + b; }
// export function subtract(a, b) { return a - b; }

// main.js
// import { add, subtract } from './math.js';
```

### 8.2 性能最佳实践

**问题描述**：代码性能不佳，影响用户体验。

**解决方案**：
- 减少 DOM 操作
- 优化循环和条件判断
- 使用适当的数据结构
- 避免不必要的计算
- 利用缓存
- 考虑使用 Web Workers 处理耗时任务

**示例**：
```javascript
// 优化循环
const items = [1, 2, 3, 4, 5];

// 低效：每次循环都访问 items.length
for (let i = 0; i < items.length; i++) {
  console.log(items[i]);
}

// 高效：缓存长度
const length = items.length;
for (let i = 0; i < length; i++) {
  console.log(items[i]);
}

// 更高效：使用 forEach 或 for...of
items.forEach(item => {
  console.log(item);
});

// 利用缓存
function expensiveCalculation(n) {
  console.log("执行昂贵计算");
  return n * n;
}

// 使用缓存
const cache = new Map();
function calculateWithCache(n) {
  if (cache.has(n)) {
    return cache.get(n);
  }
  const result = expensiveCalculation(n);
  cache.set(n, result);
  return result;
}

console.log(calculateWithCache(5)); // 执行昂贵计算，返回 25
console.log(calculateWithCache(5)); // 从缓存获取，返回 25

// 使用 Web Workers 处理耗时任务
// main.js
// const worker = new Worker('worker.js');
// worker.postMessage({ number: 1000000 });
// worker.onmessage = function(e) {
//   console.log('计算结果:', e.data);
// };

// worker.js
// onmessage = function(e) {
//   const number = e.data.number;
//   let result = 0;
//   for (let i = 0; i < number; i++) {
//     result += i;
//   }
//   postMessage({ result: result });
// };
```

## 9. 总结

JavaScript 常见问题主要包括变量和数据类型、作用域和闭包、异步编程、DOM 操作、数组和对象操作、性能优化和调试技巧等方面。通过理解 JavaScript 的核心概念和最佳实践，可以编写高质量、可维护、高性能的 JavaScript 代码。

在开发过程中，应该：
- 理解 JavaScript 的核心概念和特性
- 遵循最佳实践和代码风格
- 利用浏览器开发者工具进行调试
- 考虑性能优化
- 编写可维护和可测试的代码

通过不断学习和实践，可以提高 JavaScript 开发技能，解决各种常见问题，构建更好的 Web 应用。