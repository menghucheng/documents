# AngularJS 指令

## 1. 指令概述

指令是 AngularJS 的核心特性之一，它允许开发者扩展 HTML 语法，创建自定义的 HTML 元素、属性、类名或注释，实现组件化开发和代码复用。

AngularJS 内置了许多指令，如 `ng-app`、`ng-controller`、`ng-model` 等，同时也允许开发者创建自定义指令。

## 2. 指令的类型

根据指令在 HTML 中的使用方式，AngularJS 指令可以分为以下几种类型：

### 2.1 元素指令（E 型指令）

作为 HTML 元素使用：

```html
<my-directive></my-directive>
```

### 2.2 属性指令（A 型指令）

作为 HTML 属性使用：

```html
<div my-directive></div>
```

### 2.3 类指令（C 型指令）

作为 HTML 类名使用：

```html
<div class="my-directive"></div>
```

### 2.4 注释指令（M 型指令）

作为 HTML 注释使用：

```html
<!-- directive: my-directive -->
```

## 3. 内置指令

AngularJS 提供了丰富的内置指令，以下是一些常用的内置指令：

| 指令 | 描述 | 类型 |
|------|------|------|
| `ng-app` | 定义 AngularJS 应用程序的根元素 | 属性 |
| `ng-controller` | 定义控制器的作用域 | 属性 |
| `ng-model` | 将表单控件与模型数据绑定 | 属性 |
| `ng-repeat` | 遍历数组或对象，生成重复的 HTML 元素 | 属性 |
| `ng-click` | 绑定点击事件 | 属性 |
| `ng-show` / `ng-hide` | 根据条件显示或隐藏元素 | 属性 |
| `ng-if` / `ng-switch` | 根据条件创建或移除元素 | 属性 |
| `ng-class` | 动态添加或移除 CSS 类 | 属性 |
| `ng-style` | 动态添加内联样式 | 属性 |
| `ng-src` / `ng-href` | 动态设置资源 URL | 属性 |
| `ng-form` | 创建嵌套表单 | 元素/属性 |
| `ng-submit` | 绑定表单提交事件 | 属性 |
| `ng-options` | 为 select 元素生成选项 | 属性 |

## 4. 自定义指令

### 4.1 基本语法

使用 `angular.module().directive()` 方法创建自定义指令：

```javascript
var app = angular.module('myApp', []);

app.directive('myDirective', function() {
  return {
    // 指令配置
    restrict: 'E', // 指令类型
    template: '<h2>这是一个自定义指令</h2>' // 指令模板
  };
});
```

### 4.2 指令的配置选项

| 选项 | 类型 | 描述 |
|------|------|------|
| `restrict` | 字符串 | 指令的使用方式：E（元素）、A（属性）、C（类）、M（注释），默认值为 "A" |
| `template` | 字符串/函数 | 指令的 HTML 模板 |
| `templateUrl` | 字符串/函数 | 指令模板的 URL |
| `replace` | 布尔值 | 是否替换指令所在的元素，默认值为 false |
| `transclude` | 布尔值/字符串 | 是否保留指令元素的内容，默认值为 false |
| `scope` | 布尔值/对象 | 指令的作用域：false（继承父作用域）、true（创建新的作用域）、对象（创建隔离作用域） |
| `controller` | 字符串/函数 | 指令的控制器 |
| `controllerAs` | 字符串 | 控制器的别名 |
| `link` | 函数 | 指令的链接函数，用于处理 DOM 操作和事件绑定 |
| `compile` | 函数 | 指令的编译函数，用于编译模板 |
| `priority` | 数字 | 指令的优先级，用于确定指令的执行顺序 |
| `terminal` | 布尔值 | 是否终止同一元素上优先级较低的指令 |

### 4.3 指令的作用域

指令的作用域配置决定了指令如何与父作用域交互：

#### 4.3.1 继承父作用域（scope: false）

指令使用父作用域，对作用域的修改会影响父作用域。

```javascript
app.directive('myDirective', function() {
  return {
    restrict: 'E',
    scope: false, // 继承父作用域
    template: '<h2>{{message}}</h2>'
  };
});
```

#### 4.3.2 创建新的作用域（scope: true）

指令创建一个新的作用域，该作用域继承父作用域，但对作用域的修改不会影响父作用域（除非修改的是对象的属性）。

```javascript
app.directive('myDirective', function() {
  return {
    restrict: 'E',
    scope: true, // 创建新的作用域
    template: '<h2>{{message}}</h2><button ng-click="updateMessage()">更新消息</button>',
    link: function(scope) {
      scope.updateMessage = function() {
        scope.message = "更新后的消息";
      };
    }
  };
});
```

#### 4.3.3 创建隔离作用域（scope: {}）

指令创建一个完全独立的作用域，通过绑定与父作用域进行通信。

| 绑定方式 | 语法 | 描述 |
|---------|------|------|
| 单向绑定 | `@` | 将父作用域的值作为字符串传递给指令 |
| 双向绑定 | `=` | 将父作用域的值双向绑定到指令 |
| 函数绑定 | `&` | 将父作用域的函数传递给指令 |

```javascript
app.directive('myDirective', function() {
  return {
    restrict: 'E',
    scope: {
      name: '@', // 单向绑定
      age: '=', // 双向绑定
      greet: '&' // 函数绑定
    },
    template: `
      <div>
        <h2>Hello {{name}}</h2>
        <p>年龄: {{age}}</p>
        <button ng-click="greet()">打招呼</button>
        <button ng-click="age++">增加年龄</button>
      </div>
    `
  };
});
```

```html
<my-directive name="{{username}}" age="userAge" greet="sayHello()"></my-directive>
```

### 4.4 指令的模板

指令的模板可以通过 `template` 或 `templateUrl` 配置：

#### 4.4.1 使用 template 字符串

```javascript
app.directive('myDirective', function() {
  return {
    restrict: 'E',
    template: '<div><h2>这是一个自定义指令</h2><p>{{content}}</p></div>'
  };
});
```

#### 4.4.2 使用 templateUrl

```javascript
app.directive('myDirective', function() {
  return {
    restrict: 'E',
    templateUrl: 'my-directive.html' // 模板文件路径
  };
});
```

模板文件 `my-directive.html`：
```html
<div>
  <h2>这是一个自定义指令</h2>
  <p>{{content}}</p>
</div>
```

### 4.5 指令的链接函数

链接函数是指令中最重要的部分，用于处理 DOM 操作、事件绑定和数据初始化。

```javascript
app.directive('myDirective', function() {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      // scope：指令的作用域
      // element：指令所在的 DOM 元素
      // attrs：指令的属性集合
      
      // 修改元素样式
      element.css('color', 'red');
      
      // 绑定事件
      element.on('click', function() {
        scope.$apply(function() {
          scope.message = "元素被点击了";
        });
      });
      
      // 监听属性变化
      attrs.$observe('myDirective', function(value) {
        console.log('属性值变化为：', value);
      });
    }
  };
});
```

### 4.6 指令的编译函数

编译函数用于编译指令的模板，返回链接函数。编译函数在指令被编译时执行一次，而链接函数在每个指令实例上执行一次。

```javascript
app.directive('myDirective', function() {
  return {
    restrict: 'E',
    template: '<div>{{message}}</div>',
    compile: function(tElement, tAttrs) {
      // tElement：模板元素
      // tAttrs：模板属性
      
      console.log('编译指令模板');
      
      // 返回链接函数
      return function link(scope, element, attrs) {
        console.log('链接指令实例');
        scope.message = "Hello AngularJS";
      };
    }
  };
});
```

### 4.7 指令的控制器

指令可以定义自己的控制器，用于与其他指令通信或共享逻辑。

```javascript
app.directive('parentDirective', function() {
  return {
    restrict: 'E',
    controller: function($scope) {
      $scope.items = [];
      
      this.addItem = function(item) {
        $scope.items.push(item);
      };
      
      this.getItems = function() {
        return $scope.items;
      };
    },
    template: '<div><h2>父指令</h2><div ng-transclude></div><ul><li ng-repeat="item in items">{{item}}</li></ul></div>',
    transclude: true
  };
});

app.directive('childDirective', function() {
  return {
    restrict: 'E',
    require: '^parentDirective', // 依赖父指令的控制器
    link: function(scope, element, attrs, parentCtrl) {
      // 使用父指令的控制器方法
      parentCtrl.addItem('子指令添加的项目');
    },
    template: '<div>子指令</div>'
  };
});
```

```html
<parent-directive>
  <child-directive></child-directive>
</parent-directive>
```

## 5. 指令的生命周期

指令的生命周期包括以下阶段：

### 5.1 编译阶段（Compile）

- 执行编译函数，处理指令的模板
- 返回链接函数
- 只执行一次，无论指令被使用多少次

### 5.2 链接阶段（Link）

- 执行链接函数，处理 DOM 操作和事件绑定
- 在每个指令实例上执行一次
- 分为预链接（pre-link）和后链接（post-link）

### 5.3 控制器阶段（Controller）

- 创建指令的控制器
- 用于指令间通信

## 6. 自定义指令的最佳实践

### 6.1 指令命名约定

- 指令名称使用驼峰命名法，如 `myDirective`
- 在 HTML 中使用时，转换为短横线分隔的形式，如 `<my-directive>`
- 避免使用与内置指令或其他库冲突的名称

### 6.2 指令的职责单一

每个指令应该只负责一个功能，保持指令的简洁性和可复用性。

### 6.3 避免在指令中进行复杂的业务逻辑

复杂的业务逻辑应该封装到服务中，指令只负责 DOM 操作和事件处理。

### 6.4 使用隔离作用域

对于可复用的指令，建议使用隔离作用域，避免与父作用域产生意外的冲突。

### 6.5 优先使用属性指令

除了组件化指令外，优先使用属性指令，因为属性指令对 HTML 结构的影响较小，更符合 HTML 标准。

### 6.6 注意指令的性能

- 避免在指令的链接函数中进行复杂的计算
- 对于大量重复的指令，考虑使用 `track by` 优化 `ng-repeat`
- 避免不必要的 `$watch` 和 `$apply`

## 7. 指令与组件的关系

在 AngularJS 1.5+ 中，引入了组件（Component）概念，它是基于指令的简化版本，更接近 Angular 2+ 的组件模型。

组件的特点：

- 总是使用隔离作用域
- 只能通过元素或属性使用
- 支持生命周期钩子
- 更简洁的语法

```javascript
// 组件定义
app.component('myComponent', {
  bindings: {
    name: '@',
    age: '='
  },
  templateUrl: 'my-component.html',
  controller: function() {
    var vm = this;
    
    vm.$onInit = function() {
      // 初始化逻辑
    };
    
    vm.sayHello = function() {
      return "Hello " + vm.name;
    };
  }
});
```

## 8. 总结

指令是 AngularJS 的核心特性之一，它允许开发者扩展 HTML 语法，实现组件化开发和代码复用。通过自定义指令，可以将复杂的 DOM 操作和业务逻辑封装起来，提高代码的可维护性和可测试性。

掌握指令的创建和使用，对于开发复杂的 AngularJS 应用至关重要。在创建自定义指令时，应该遵循最佳实践，保持指令的简洁性、可复用性和高性能。