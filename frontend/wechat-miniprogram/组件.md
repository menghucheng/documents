# 微信小程序组件

## 1. 组件概述

组件是微信小程序的基本构建单元，用于构建页面的各个部分。小程序提供了丰富的内置组件，同时也允许开发者创建自定义组件。

组件具有以下特点：
- 可复用性：组件可以在多个页面中重复使用
- 封装性：组件将功能封装成独立的单元，便于维护和管理
- 组合性：组件可以组合使用，构建复杂的页面结构

## 2. 内置组件

微信小程序提供了丰富的内置组件，涵盖了布局、表单、媒体、导航等多个方面。以下是一些常用的内置组件：

### 2.1 基础组件

| 组件 | 描述 | 主要属性 |
|------|------|----------|
| `<view>` | 视图容器，类似HTML的`<div>` | `class`、`style`、`hidden`、`bindtap`等 |
| `<text>` | 文本容器，用于显示文本 | `class`、`style`、`selectable`、`decode`等 |
| `<image>` | 图片组件 | `src`、`mode`、`bindload`、`binderror`等 |
| `<icon>` | 图标组件 | `type`、`size`、`color`等 |
| `<progress>` | 进度条组件 | `percent`、`show-info`、`active`等 |

### 2.2 表单组件

| 组件 | 描述 | 主要属性 |
|------|------|----------|
| `<button>` | 按钮组件 | `type`、`size`、`plain`、`disabled`、`bindtap`等 |
| `<input>` | 输入框组件 | `value`、`type`、`placeholder`、`bindinput`、`bindconfirm`等 |
| `<textarea>` | 多行文本输入组件 | `value`、`placeholder`、`auto-height`、`bindinput`等 |
| `<switch>` | 开关组件 | `checked`、`type`、`bindchange`等 |
| `<slider>` | 滑块组件 | `min`、`max`、`value`、`bindchange`等 |
| `<radio>` | 单选框组件 | `value`、`checked`、`bindchange`等 |
| `<checkbox>` | 复选框组件 | `value`、`checked`、`bindchange`等 |
| `<picker>` | 选择器组件 | `mode`、`range`、`value`、`bindchange`等 |
| `<picker-view>` | 滚动选择器组件 | `value`、`indicator-style`、`bindchange`等 |

### 2.3 导航组件

| 组件 | 描述 | 主要属性 |
|------|------|----------|
| `<navigator>` | 页面导航组件 | `url`、`open-type`、`delta`、`bindsuccess`等 |
| `<functional-page-navigator>` | 跳转到功能页的组件 | `name`、`args`、`version`等 |

### 2.4 媒体组件

| 组件 | 描述 | 主要属性 |
|------|------|----------|
| `<audio>` | 音频组件 | `src`、`autoplay`、`loop`、`bindtimeupdate`等 |
| `<video>` | 视频组件 | `src`、`autoplay`、`loop`、`bindplay`、`bindpause`等 |
| `<camera>` | 相机组件 | `device-position`、`flash`、`bindstop`、`binderror`等 |
| `<live-player>` | 实时音视频播放组件 | `src`、`mode`、`autoplay`、`bindstatechange`等 |
| `<live-pusher>` | 实时音视频录制组件 | `url`、`mode`、`autopush`、`bindstatechange`等 |

### 2.5 地图组件

| 组件 | 描述 | 主要属性 |
|------|------|----------|
| `<map>` | 地图组件 | `latitude`、`longitude`、`scale`、`markers`、`polylines`等 |
| `<cover-view>` | 地图覆盖物容器 | `class`、`style`等 |
| `<cover-image>` | 地图覆盖物图片 | `src`、`class`、`style`等 |

### 2.6 画布组件

| 组件 | 描述 | 主要属性 |
|------|------|----------|
| `<canvas>` | 画布组件 | `canvas-id`、`type`、`width`、`height`等 |

## 3. 内置组件的使用

### 3.1 基础组件使用示例

#### 3.1.1 `<view>` 组件

```wxml
<view class="container">
  <view class="box" bindtap="onTap">
    <text>点击我</text>
  </view>
</view>
```

```wxss
.container {
  padding: 20rpx;
}

.box {
  width: 200rpx;
  height: 200rpx;
  background-color: #07c160;
  border-radius: 10rpx;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
}
```

```javascript
Page({
  onTap: function() {
    wx.showToast({
      title: '点击了视图',
      icon: 'success'
    });
  }
});
```

#### 3.1.2 `<image>` 组件

```wxml
<image 
  src="https://example.com/image.jpg" 
  mode="aspectFill" 
  bindload="onImageLoad" 
  binderror="onImageError"
  style="width: 100%; height: 300rpx;"
/>
```

```javascript
Page({
  onImageLoad: function(e) {
    console.log('图片加载成功', e);
  },
  onImageError: function(e) {
    console.error('图片加载失败', e);
  }
});
```

### 3.2 表单组件使用示例

#### 3.2.1 `<button>` 组件

```wxml
<view class="button-container">
  <button type="primary" bindtap="onPrimaryTap">主按钮</button>
  <button type="default" bindtap="onDefaultTap">默认按钮</button>
  <button type="warn" bindtap="onWarnTap">警告按钮</button>
  <button plain bindtap="onPlainTap">镂空按钮</button>
  <button disabled bindtap="onDisabledTap">禁用按钮</button>
  <button size="mini" bindtap="onMiniTap">小型按钮</button>
</view>
```

```wxss
.button-container {
  padding: 20rpx;
  display: flex;
  flex-direction: column;
  gap: 10rpx;
}
```

#### 3.2.2 `<input>` 组件

```wxml
<view class="input-container">
  <text>用户名：</text>
  <input 
    placeholder="请输入用户名" 
    value="{{username}}" 
    bindinput="onUsernameInput"
    class="input"
  />
  
  <text>密码：</text>
  <input 
    type="password" 
    placeholder="请输入密码" 
    value="{{password}}" 
    bindinput="onPasswordInput"
    class="input"
  />
  
  <button type="primary" bindtap="onLogin">登录</button>
</view>
```

```wxss
.input-container {
  padding: 20rpx;
  display: flex;
  flex-direction: column;
  gap: 15rpx;
}

.input {
  border: 1rpx solid #ddd;
  border-radius: 8rpx;
  padding: 15rpx;
  font-size: 28rpx;
}
```

```javascript
Page({
  data: {
    username: '',
    password: ''
  },
  onUsernameInput: function(e) {
    this.setData({
      username: e.detail.value
    });
  },
  onPasswordInput: function(e) {
    this.setData({
      password: e.detail.value
    });
  },
  onLogin: function() {
    // 处理登录逻辑
    console.log('登录信息：', this.data.username, this.data.password);
  }
});
```

### 3.3 导航组件使用示例

#### 3.3.1 `<navigator>` 组件

```wxml
<view class="nav-container">
  <!-- 跳转到新页面 -->
  <navigator url="/pages/detail/detail?id=1" hover-class="nav-hover">
    查看详情
  </navigator>
  
  <!-- 重定向 -->
  <navigator url="/pages/login/login" open-type="redirect" hover-class="nav-hover">
    登录
  </navigator>
  
  <!-- 返回上一页 -->
  <navigator open-type="navigateBack" delta="1" hover-class="nav-hover">
    返回
  </navigator>
  
  <!-- 跳转到 tabBar 页面 -->
  <navigator url="/pages/home/home" open-type="switchTab" hover-class="nav-hover">
    首页
  </navigator>
</view>
```

```wxss
.nav-container {
  padding: 20rpx;
  display: flex;
  flex-direction: column;
  gap: 15rpx;
}

navigator {
  padding: 15rpx;
  background-color: #f5f5f5;
  border-radius: 8rpx;
  text-align: center;
  font-size: 28rpx;
  color: #333;
}

.nav-hover {
  background-color: #e5e5e5;
}
```

## 4. 自定义组件

除了使用内置组件外，开发者还可以创建自定义组件，实现组件化开发，提高代码的复用性和可维护性。

### 4.1 创建自定义组件

创建自定义组件需要以下步骤：

1. **创建组件目录和文件**
   - 在项目根目录下创建`components`目录
   - 在`components`目录下创建组件目录，如`my-component`
   - 在组件目录下创建`my-component.js`、`my-component.json`、`my-component.wxml`、`my-component.wxss`文件

2. **配置组件**
   - 在`my-component.json`中声明这是一个组件：
     ```json
     {
       "component": true
     }
     ```

3. **编写组件代码**
   - 编写`my-component.wxml`，定义组件的结构
   - 编写`my-component.wxss`，定义组件的样式
   - 编写`my-component.js`，实现组件的逻辑

### 4.2 自定义组件示例

#### 4.2.1 组件结构（my-component.wxml）

```wxml
<view class="my-component">
  <view class="component-header">
    <text class="component-title">{{title}}</text>
    <button size="mini" bindtap="onClose">关闭</button>
  </view>
  <view class="component-content">
    <slot></slot>
  </view>
</view>
```

#### 4.2.2 组件样式（my-component.wxss）

```wxss
.my-component {
  border: 1rpx solid #ddd;
  border-radius: 10rpx;
  background-color: white;
  box-shadow: 0 2rpx 10rpx rgba(0, 0, 0, 0.1);
}

.component-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15rpx 20rpx;
  border-bottom: 1rpx solid #f0f0f0;
}

.component-title {
  font-size: 32rpx;
  font-weight: bold;
  color: #333;
}

.component-content {
  padding: 20rpx;
}
```

#### 4.2.3 组件逻辑（my-component.js）

```javascript
Component({
  // 组件的属性列表
  properties: {
    title: {
      type: String,
      value: '默认标题'
    }
  },
  
  // 组件的初始数据
  data: {
    isShow: true
  },
  
  // 组件的方法列表
  methods: {
    onClose: function() {
      // 触发自定义事件，通知父组件
      this.triggerEvent('close', { message: '组件被关闭了' });
      
      // 更新组件内部状态
      this.setData({
        isShow: false
      });
    }
  },
  
  // 组件生命周期函数
  lifetimes: {
    attached: function() {
      // 组件被添加到页面时执行
      console.log('组件被添加到页面');
    },
    detached: function() {
      // 组件被从页面移除时执行
      console.log('组件被从页面移除');
    }
  }
});
```

### 4.3 使用自定义组件

在页面中使用自定义组件需要以下步骤：

1. **在页面配置中引入组件**
   - 在页面的JSON文件中（如`index.json`）引入组件：
     ```json
     {
       "usingComponents": {
         "my-component": "../../components/my-component/my-component"
       }
     }
     ```

2. **在页面中使用组件**
   - 在页面的WXML文件中（如`index.wxml`）使用组件：
     ```wxml
     <view class="page-container">
       <my-component 
         title="我的组件" 
         bind:close="onComponentClose"
       >
         <text>这是组件的内容</text>
       </my-component>
     </view>
     ```

3. **在页面中处理组件事件**
   - 在页面的JavaScript文件中（如`index.js`）处理组件触发的事件：
     ```javascript
     Page({
       onComponentClose: function(e) {
         console.log('组件关闭事件：', e.detail.message);
       }
     });
     ```

## 5. 组件通信

### 5.1 父组件向子组件传递数据

通过组件的属性（properties）传递数据：

```wxml
<!-- 父组件 -->
<my-component title="父组件传递的标题" content="父组件传递的内容"></my-component>
```

```javascript
// 子组件
Component({
  properties: {
    title: {
      type: String,
      value: '默认标题'
    },
    content: {
      type: String,
      value: '默认内容'
    }
  }
});
```

### 5.2 子组件向父组件传递数据

通过`triggerEvent`方法触发自定义事件：

```javascript
// 子组件
Component({
  methods: {
    onButtonTap: function() {
      // 触发自定义事件，传递数据
      this.triggerEvent('customEvent', {
        data: '子组件传递的数据'
      });
    }
  }
});
```

```wxml
<!-- 父组件 -->
<my-component bind:customEvent="onCustomEvent"></my-component>
```

```javascript
// 父组件
Page({
  onCustomEvent: function(e) {
    // 接收子组件传递的数据
    console.log('子组件传递的数据：', e.detail.data);
  }
});
```

### 5.3 组件间通信

对于非父子关系的组件，可以使用以下方式通信：

1. **使用全局数据**：将数据存储在`app.js`的`globalData`中，通过`getApp()`访问
2. **使用事件总线**：创建一个事件总线，用于组件间事件的发布和订阅
3. **使用`wx.navigateTo`传递数据**：通过URL参数传递数据

## 6. 组件的生命周期

### 6.1 组件生命周期函数

组件具有以下生命周期函数：

| 生命周期函数 | 描述 |
|------------|------|
| `created` | 组件实例刚刚被创建时执行，此时不能调用`setData` |
| `attached` | 组件实例进入页面节点树时执行，此时可以调用`setData` |
| `ready` | 组件布局完成时执行，此时可以获取节点信息 |
| `moved` | 组件实例被移动到节点树另一个位置时执行 |
| `detached` | 组件实例被从页面节点树移除时执行 |

### 6.2 组件生命周期示例

```javascript
Component({
  lifetimes: {
    created: function() {
      console.log('组件被创建');
    },
    attached: function() {
      console.log('组件被添加到页面');
      // 可以调用setData
      this.setData({
        message: '组件初始化完成'
      });
    },
    ready: function() {
      console.log('组件布局完成');
      // 可以获取节点信息
      const query = this.createSelectorQuery();
      query.select('.component-content').boundingClientRect();
      query.exec(function(res) {
        console.log('组件内容区域大小：', res[0]);
      });
    },
    detached: function() {
      console.log('组件被从页面移除');
      // 清理资源
    }
  }
});
```

## 7. 组件的最佳实践

### 7.1 组件的职责单一

每个组件应该只负责一个功能，保持组件的简洁性和可复用性。

### 7.2 组件的命名规范

- 组件名称使用小写字母和连字符，如`my-component`
- 组件目录名称与组件名称保持一致
- 组件的属性和事件名称使用驼峰命名法，如`bind:customEvent`

### 7.3 组件的样式隔离

组件的样式默认是隔离的，只作用于组件内部，不影响外部页面。可以通过`styleIsolation`属性控制样式隔离：

```json
// 组件配置
{
  "component": true,
  "styleIsolation": "isolated" // isolated、apply-shared、shared
}
```

### 7.4 组件的性能优化

- 避免在组件中频繁调用`setData`，尽量合并多次`setData`调用
- 对于大型列表，使用`wx:key`提高渲染性能
- 避免在组件的生命周期函数中执行复杂的计算和网络请求
- 使用`virtual-list`组件优化长列表性能

## 8. 总结

组件是微信小程序开发的重要组成部分，掌握组件的使用和开发对于构建高质量的小程序至关重要。

微信小程序提供了丰富的内置组件，可以满足大多数开发需求。同时，自定义组件允许开发者封装复杂的功能，提高代码的复用性和可维护性。

通过合理使用组件，可以构建出结构清晰、性能优良、易于维护的小程序应用。