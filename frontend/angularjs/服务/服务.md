# AngularJS 服务

## 1. 服务概述

服务是 AngularJS 中可复用的单例对象，用于封装业务逻辑、数据访问和其他跨组件共享的功能。服务通过依赖注入机制在控制器、指令和其他服务中使用。

AngularJS 服务的主要特点：
- 单例：每个服务在应用程序中只有一个实例
- 延迟初始化：服务在第一次被注入时才会创建
- 可测试：通过依赖注入，服务可以轻松进行单元测试
- 可复用：服务可以在多个控制器和指令中共享

## 2. 内置服务

AngularJS 提供了丰富的内置服务，以下是一些常用的内置服务：

| 服务 | 描述 |
|------|------|
| `$rootScope` | 所有作用域的根作用域，用于在全局范围内共享数据 |
| `$scope` | 控制器的作用域，用于连接控制器和视图 |
| `$http` | 用于发送 HTTP 请求，支持 GET、POST、PUT、DELETE 等方法 |
| `$resource` | 基于 `$http` 的高级服务，用于与 RESTful API 交互 |
| `$timeout` | 封装 `setTimeout`，支持 AngularJS 的消化周期 |
| `$interval` | 封装 `setInterval`，支持 AngularJS 的消化周期 |
| `$location` | 用于处理 URL，获取和修改当前页面的 URL |
| `$routeProvider` / `$stateProvider` | 用于配置应用程序的路由 |
| `$q` | 用于处理异步操作和 Promise |
| `$filter` | 用于格式化数据，如日期、货币、大小写转换等 |
| `$log` | 用于日志记录，替代 `console.log` |
| `$window` | 封装浏览器的 `window` 对象，便于测试 |
| `$document` | 封装浏览器的 `document` 对象，便于测试 |
| `$cookies` / `$cookieStore` | 用于处理浏览器的 cookie |
| `$cacheFactory` | 用于创建和管理缓存 |

## 3. 自定义服务

### 3.1 服务的创建方式

AngularJS 提供了多种创建自定义服务的方式：

- **factory()**：返回一个对象或函数，作为服务实例
- **service()**：使用构造函数创建服务实例
- **provider()**：创建一个可配置的服务，是最灵活的服务创建方式
- **constant()**：创建一个不可修改的常量服务
- **value()**：创建一个可修改的值服务

### 3.2 使用 factory() 创建服务

`factory()` 方法是创建服务最常用的方式，它接受一个函数，该函数返回服务实例。

```javascript
var app = angular.module('myApp', []);

app.factory('dataService', function($http) {
  // 服务的私有变量
  var baseUrl = '/api';
  
  // 服务的公共方法
  return {
    // 获取所有数据
    getAll: function() {
      return $http.get(baseUrl + '/data');
    },
    
    // 获取单个数据
    getById: function(id) {
      return $http.get(baseUrl + '/data/' + id);
    },
    
    // 创建数据
    create: function(data) {
      return $http.post(baseUrl + '/data', data);
    },
    
    // 更新数据
    update: function(id, data) {
      return $http.put(baseUrl + '/data/' + id, data);
    },
    
    // 删除数据
    delete: function(id) {
      return $http.delete(baseUrl + '/data/' + id);
    }
  };
});
```

### 3.3 使用 service() 创建服务

`service()` 方法使用构造函数创建服务实例，AngularJS 会使用 `new` 关键字实例化服务。

```javascript
app.service('userService', function() {
  // 服务的属性
  this.currentUser = null;
  
  // 服务的方法
  this.login = function(username, password) {
    // 登录逻辑
    this.currentUser = { username: username };
    return true;
  };
  
  this.logout = function() {
    // 登出逻辑
    this.currentUser = null;
  };
  
  this.isLoggedIn = function() {
    return this.currentUser !== null;
  };
  
  this.getCurrentUser = function() {
    return this.currentUser;
  };
});
```

### 3.4 使用 provider() 创建服务

`provider()` 方法是最灵活的服务创建方式，允许在应用程序配置阶段配置服务。

```javascript
app.provider('configService', function() {
  // 可配置的属性
  var apiUrl = 'http://api.example.com';
  var debug = false;
  
  // 配置方法，在 config 阶段调用
  this.setApiUrl = function(url) {
    apiUrl = url;
  };
  
  this.setDebug = function(debugMode) {
    debug = debugMode;
  };
  
  // $get 方法，返回服务实例
  this.$get = function() {
    return {
      getApiUrl: function() {
        return apiUrl;
      },
      isDebug: function() {
        return debug;
      },
      log: function(message) {
        if (debug) {
          console.log('[DEBUG]', message);
        }
      }
    };
  };
});

// 在配置阶段配置服务
app.config(function(configServiceProvider) {
  configServiceProvider.setApiUrl('http://api.production.com');
  configServiceProvider.setDebug(false);
});
```

### 3.5 使用 constant() 和 value() 创建服务

- **constant()**：创建不可修改的常量服务，可在配置阶段使用
- **value()**：创建可修改的值服务，不能在配置阶段使用

```javascript
// 创建常量服务
app.constant('API_URL', 'http://api.example.com');

// 创建值服务
app.value('appSettings', {
  version: '1.0.0',
  theme: 'light',
  language: 'zh-CN'
});

// 在控制器中使用
app.controller('myCtrl', function($scope, API_URL, appSettings) {
  $scope.apiUrl = API_URL;
  $scope.settings = appSettings;
  
  // 可以修改值服务
  $scope.settings.theme = 'dark';
  
  // 不能修改常量服务
  // API_URL = 'http://new-api.com'; // 这会导致错误
});
```

## 4. 服务的依赖注入

### 4.1 在控制器中注入服务

```javascript
app.controller('myCtrl', function($scope, dataService, userService) {
  // 使用 dataService 获取数据
  dataService.getAll().then(function(response) {
    $scope.data = response.data;
  });
  
  // 使用 userService 检查登录状态
  $scope.isLoggedIn = userService.isLoggedIn();
});
```

### 4.2 在服务中注入其他服务

```javascript
app.factory('authService', function($http, $q, API_URL) {
  return {
    login: function(credentials) {
      var deferred = $q.defer();
      
      $http.post(API_URL + '/login', credentials)
        .then(function(response) {
          // 登录成功
          deferred.resolve(response.data);
        })
        .catch(function(error) {
          // 登录失败
          deferred.reject(error);
        });
      
      return deferred.promise;
    }
  };
});
```

### 4.3 在指令中注入服务

```javascript
app.directive('myDirective', function(dataService) {
  return {
    restrict: 'E',
    template: '<ul><li ng-repeat="item in items">{{item.name}}</li></ul>',
    link: function(scope) {
      // 使用服务获取数据
      dataService.getAll().then(function(response) {
        scope.items = response.data;
      });
    }
  };
});
```

## 5. 服务的最佳实践

### 5.1 服务的职责单一

每个服务应该只负责一个功能领域，保持服务的简洁性和可复用性。

**不好的做法：**
```javascript
// 一个服务负责多个不相关的功能
app.factory('utilityService', function() {
  return {
    // 数据处理功能
    processData: function(data) { /* ... */ },
    
    // 认证功能
    authenticate: function(user) { /* ... */ },
    
    // 日期格式化功能
    formatDate: function(date) { /* ... */ },
    
    // 日志功能
    log: function(message) { /* ... */ }
  };
});
```

**好的做法：**
```javascript
// 每个服务负责一个功能领域
app.factory('dataService', function() { /* 数据处理功能 */ });
app.factory('authService', function() { /* 认证功能 */ });
app.factory('dateService', function() { /* 日期格式化功能 */ });
app.factory('logService', function() { /* 日志功能 */ });
```

### 5.2 使用依赖注入而非硬编码

服务应该通过依赖注入获取其依赖项，而不是直接创建或硬编码依赖项。

**不好的做法：**
```javascript
app.factory('dataService', function() {
  // 硬编码 API URL
  var apiUrl = 'http://api.example.com';
  
  return {
    getData: function() {
      // 直接使用 XMLHttpRequest，而不是注入 $http
      return new Promise(function(resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', apiUrl + '/data');
        xhr.onload = function() {
          if (xhr.status === 200) {
            resolve(JSON.parse(xhr.responseText));
          } else {
            reject(xhr.statusText);
          }
        };
        xhr.send();
      });
    }
  };
});
```

**好的做法：**
```javascript
app.factory('dataService', function($http, API_URL) {
  return {
    getData: function() {
      return $http.get(API_URL + '/data');
    }
  };
});
```

### 5.3 服务的命名约定

- 服务名称使用驼峰命名法，首字母小写
- 服务名称应该清晰地反映其功能，如 `dataService`、`authService`、`userService`
- 避免使用过于通用的名称，如 `service`、`util` 等

### 5.4 服务的测试

服务应该是可测试的，避免依赖全局状态或难以模拟的外部资源。

**可测试的服务：**
```javascript
app.factory('calculatorService', function() {
  return {
    add: function(a, b) {
      return a + b;
    },
    subtract: function(a, b) {
      return a - b;
    }
  };
});
```

## 6. 服务与工厂、提供者的区别

| 特性 | factory() | service() | provider() | constant() | value() |
|------|-----------|-----------|------------|------------|---------|
| 语法 | `app.factory('name', function() { return {}; })` | `app.service('name', function() { this.method = function() {}; })` | `app.provider('name', function() { this.$get = function() { return {}; }; })` | `app.constant('name', value)` | `app.value('name', value)` |
| 实例化方式 | 调用函数返回实例 | 使用 `new` 关键字实例化 | 调用 `$get()` 方法返回实例 | 直接使用值 | 直接使用值 |
| 可配置 | 否 | 否 | 是（在 `config` 阶段） | 否 | 否 |
| 可修改 | 是 | 是 | 是 | 否 | 是 |
| 可在配置阶段使用 | 否 | 否 | 是 | 是 | 否 |
| 性能 | 高 | 中 | 低 | 高 | 高 |
| 灵活性 | 中 | 低 | 高 | 低 | 低 |

## 7. 服务的使用场景

### 7.1 数据访问层

使用服务封装与后端 API 的交互，提供统一的数据访问接口。

```javascript
app.factory('apiService', function($http, API_URL) {
  return {
    users: {
      getAll: function() { return $http.get(API_URL + '/users'); },
      getById: function(id) { return $http.get(API_URL + '/users/' + id); },
      create: function(user) { return $http.post(API_URL + '/users', user); },
      update: function(id, user) { return $http.put(API_URL + '/users/' + id, user); },
      delete: function(id) { return $http.delete(API_URL + '/users/' + id); }
    },
    posts: {
      getAll: function() { return $http.get(API_URL + '/posts'); },
      getByUserId: function(userId) { return $http.get(API_URL + '/users/' + userId + '/posts'); }
    }
  };
});
```

### 7.2 业务逻辑层

使用服务封装复杂的业务逻辑，保持控制器的简洁性。

```javascript
app.factory('orderService', function(apiService, cartService) {
  return {
    createOrder: function(shippingInfo) {
      // 获取购物车内容
      var cartItems = cartService.getItems();
      
      // 计算订单总额
      var total = cartItems.reduce(function(sum, item) {
        return sum + (item.price * item.quantity);
      }, 0);
      
      // 创建订单对象
      var order = {
        items: cartItems,
        total: total,
        shippingInfo: shippingInfo,
        status: 'pending'
      };
      
      // 提交订单
      return apiService.orders.create(order).then(function(response) {
        // 清空购物车
        cartService.clear();
        return response.data;
      });
    }
  };
});
```

### 7.3 状态管理

使用服务管理应用程序的全局状态，如用户登录状态、主题设置等。

```javascript
app.factory('stateService', function() {
  var state = {
    user: null,
    theme: 'light',
    language: 'zh-CN'
  };
  
  return {
    getUser: function() { return state.user; },
    setUser: function(user) { state.user = user; },
    
    getTheme: function() { return state.theme; },
    setTheme: function(theme) { state.theme = theme; },
    
    getLanguage: function() { return state.language; },
    setLanguage: function(language) { state.language = language; }
  };
});
```

### 7.4 工具函数

使用服务封装通用的工具函数，如日期格式化、数据验证等。

```javascript
app.factory('utilsService', function() {
  return {
    // 日期格式化
    formatDate: function(date, format) {
      // 实现日期格式化逻辑
    },
    
    // 数据验证
    validateEmail: function(email) {
      var re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return re.test(email);
    },
    
    // 生成唯一 ID
    generateId: function() {
      return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    }
  };
});
```

## 8. 总结

服务是 AngularJS 应用程序的核心组件之一，用于封装业务逻辑、数据访问和其他跨组件共享的功能。通过依赖注入机制，服务可以在控制器、指令和其他服务中轻松使用。

AngularJS 提供了多种创建自定义服务的方式，包括 `factory()`、`service()`、`provider()`、`constant()` 和 `value()`，每种方式都有其适用场景。

遵循服务的最佳实践，如职责单一、依赖注入、可测试性等，可以提高代码的质量和可维护性，使应用程序更加健壮和易于扩展。